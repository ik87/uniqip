#  Подсчет уникальных IP

### Проблема 
Максимальное кол-во IPv4 адресов `2^32` или `4294967296` вариантов
т.к. **boolean** в **java** занимает 8бит, а максимальное кол-во элементов в массиве не может превышать `2147483647 `что в два раза меньше чем требуется, поэтому в качестве буфера который хранит промежуточные IP
использовал массив **long** размером в `2^32/64` или `67108864` элементов.
где `64` – это размер **long** т.е получилась своеобразная двоичная матрица.
по x `64` (каждый лонг) по y `67108864`
В которой размещал приходящие IP и проверял их уникальность.
Таким образом, удалось уместить все IP, затратив минимум памяти
это около` 2^32` бита или `536` мб.

### Алгоритм
Входящий IP переводится в **long**, далее для этого IP находится индекс, т.е Y
`y = IP / 64`
Далее находим ячейку т.е X, по формуле
`x = IP mod 64`
Определив позицию бита, можно задать\проверить IP


### Версии
 * [2.0] - 04-12-2020 критическое обновление. Испарвление не правильного подсчета
 * [1.1b] - 03-12-2020 ~~считает ip у которых нет повтора~~
 * [1.0b] - 21-11-2020 ~~считает ip у которых есть повторы~~

## Использованные средства
* [Open JDK 11.02](https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_windows-x64_bin.zip.sha256) - компилятор\интерпритатор
* [Maven](http://maven.apache.org/index.html) сборка и управление проектом

## Компиляция

```sh
$ cd uniqip
$ mvn package
```
Появится папка **target**, a в ней файл **uniqip.jar** 


## Запуск
```sh
$ java -jar uniq.jar ip_addresses
```

## Скорость работы (2.0)
[файл](https://ecwid-vgv-storage.s3.eu-central-1.amazonaws.com/ip_addresses.zip) размером в ~110 гб
на железе i3-4170 3.7GHz 16gb дал такие результаты:
```sh
total ip: 8000000000
unique ip: 1000000000
elapsed time:  38 M  1 S
```
